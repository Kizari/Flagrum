using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Flagrum.Generators.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Flagrum.Generators;

public enum MigrationStepMode
{
    Mandatory,
    Retry,
    Warn
}

public enum MigrationScope
{
    Application,
    Profile
}

[Generator]
public class DataMigrationSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "Flagrum.Generators";
    private const string AttributeName = "SteppedDataMigrationAttribute";
    private const string StepAttributeName = "MigrationStepAttribute";

    private const string AttributeSourceCode =
        $$"""
          /// <auto-generated/>

          namespace {{Namespace}};

          [System.AttributeUsage(System.AttributeTargets.Class)]
          public class {{AttributeName}} : System.Attribute
          {
              public {{AttributeName}}(int order) { }
          }

          public enum MigrationScope { Application, Profile }
          
          public enum MigrationStepMode { Mandatory, Retry, Warn }

          [System.AttributeUsage(System.AttributeTargets.Method)]
          public class {{StepAttributeName}} : System.Attribute
          {
              public {{StepAttributeName}}(int order, string guid, MigrationScope scope, MigrationStepMode mode = MigrationStepMode.Mandatory, string warning = null) { }
          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the [SteppedDataMigration] attribute to the source
        context.RegisterPostInitializationOutput(c => c.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Filter down to classes with the attribute
        var filteredClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (c, _) => GetClassDeclaration(c))
            .Where(r => r.HasAttribute)
            .Select((r, _) => r.Declaration)
            .Collect();

        // Generate the source code
        context.RegisterSourceOutput(context.CompilationProvider.Combine(filteredClasses),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        var orders = new List<int>();
        var allSteps = new List<MigrationStep>();
        
        foreach (var classDeclaration in classDeclarations)
        {
            var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

            if (model.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            var nameSpace = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classDeclaration.Identifier.Text;
            var methods = GetStepMethods(classSymbol).ToList();

            foreach (var method in methods)
            {
                method.Namespace = nameSpace;
                method.ClassName = className;
            }

            if (methods.Count(m => m.Mode == MigrationStepMode.Warn) > 1)
            {
                context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                    "FLSG00001",
                    "SteppedDataMigration cannot have more than one step that reports a warning.",
                    "SteppedDataMigration cannot have more than one step that reports a warning.",
                    "Flagrum.Data.Migration",
                    DiagnosticSeverity.Error,
                    true), classDeclaration.GetLocation()));
            }

            if (methods.GroupBy(m => m.Order).Any(g => g.Count() > 1))
            {
                context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                    "FLSG00002",
                    "Multiple MigrationStep methods cannot share the same index.",
                    "Multiple MigrationStep methods cannot share the same index.",
                    "Flagrum.Data.Migration",
                    DiagnosticSeverity.Error,
                    true), classDeclaration.GetLocation()));
            }

            allSteps.AddRange(methods);
            var constructorArguments = classSymbol.GetAttributes()
                .First(a => a.AttributeClass?.ToDisplayString() == $"{Namespace}.{AttributeName}")
                .ConstructorArguments;

            var shouldRun = string.Join("\r\n        && ", methods
                .Select(m => $"{Service(m)}.HasMigrated({m.MethodName}Id)"));

            var runSteps = methods
                .OrderBy(m => m.Order)
                .Select(m =>
                {
                    var catchBody = m.Mode == MigrationStepMode.Warn
                        ? $"""
                                           MessageBox.Show("{m.Warning}",
                                               "Warning", MessageBoxButton.OK, MessageBoxImage.Warning);
                                               
                                           // Warned migrations won't be retried
                                           {Service(m)}.SetMigrated({m.MethodName}Id);
                           """
                        : "                // Doing nothing so this will be retried next launch";

                    var catchBlock = $$"""
                                       }
                                                   catch
                                                   {
                                       {{catchBody}}
                                                   }
                                       """;

                    return
                        $$"""
                                  if (!{{Service(m)}}.HasMigrated({{m.MethodName}}Id))
                                  {
                                      {{(m.Mode == MigrationStepMode.Mandatory ? "" : "try\r\n            {")}}
                                      {{(m.IsTask ? "await " : "")}}{{m.MethodName}}();
                                      {{Service(m)}}.SetMigrated({{m.MethodName}}Id);
                                      {{(m.Mode == MigrationStepMode.Mandatory ? "" : catchBlock)}}
                                  }
                          """;
                });

            var order = (int)constructorArguments[0].Value!;
            orders.Add(order);
            var hasTasks = methods.Any(m => m.IsTask);
            var source = $$"""
                           /// <auto-generated />

                           using System.Threading.Tasks;
                           using System.Windows;
                           using System.Collections.Generic;

                           namespace {{nameSpace}};

                           public partial class {{className}} : IDataMigration
                           {
                               {{string.Join("\r\n    ", methods.Select(m => $"public static System.Guid {m.MethodName}Id = new(\"{m.Guid}\");"))}}
                           
                               public static HashSet<System.Guid> ApplicationSteps =>
                               [
                                   {{string.Join(",\r\n        ", methods.Where(m => m.Scope == MigrationScope.Application).Select(m => $"{m.MethodName}Id"))}}
                               ];
                               
                               public static HashSet<System.Guid> ProfileSteps =>
                               [
                                   {{string.Join(",\r\n        ", methods.Where(m => m.Scope == MigrationScope.Profile).Select(m => $"{m.MethodName}Id"))}}
                               ];
                           
                               public int Order => {{order}};
                           
                               public bool ShouldRun => !({{shouldRun}});
                               
                               public {{(hasTasks ? "async " : "")}}Task RunAsync()
                               {
                           {{string.Join("\r\n\r\n", runSteps)}}{{(hasTasks ? "" : "\r\n\r\n        return Task.CompletedTask;")}}
                               }
                           }
                           """;

            context.AddSource($"{nameSpace}.{className}.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        if (orders.GroupBy(o => o).Any(g => g.Count() > 1))
        {
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                "FLSG00003",
                "SteppedDataMigration cannot share the same index as another migration.",
                "SteppedDataMigration cannot share the same index as another migration.",
                "Flagrum.Data.Migration",
                DiagnosticSeverity.Error,
                true), Location.None));
        }

        var staticSource = $$"""
                             /// <auto-generated />

                             namespace {{Namespace}};

                             public static class SteppedMigrationHelper
                             {
                                 public static System.Collections.Generic.HashSet<System.Guid> ApplicationSteps =>
                                 [
                                     {{string.Join(",\r\n        ", allSteps.Where(s => s.Scope == MigrationScope.Application).Select(s => $"{s.Namespace}.{s.ClassName}.{s.MethodName}Id"))}}
                                 ];
                                 
                                 public static System.Collections.Generic.HashSet<System.Guid> ProfileSteps =>
                                 [
                                     {{string.Join(",\r\n        ", allSteps.Where(s => s.Scope == MigrationScope.Profile).Select(s => $"{s.Namespace}.{s.ClassName}.{s.MethodName}Id"))}}
                                 ];
                             }
                             """;
        context.AddSource("SteppedMigrationHelper.g.cs", SourceText.From(staticSource, Encoding.UTF8));
    }

    private static IEnumerable<MigrationStep> GetStepMethods(ITypeSymbol typeSymbol)
    {
        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is IMethodSymbol methodSymbol)
            {
                // Check if the method has MigrationStepAttribute
                var migrationStepAttribute = methodSymbol
                    .GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == $"{Namespace}.{StepAttributeName}");

                if (migrationStepAttribute != null)
                {
                    yield return new MigrationStep
                    {
                        Order = (int)migrationStepAttribute.ConstructorArguments[0].Value!,
                        Guid = new Guid((string)migrationStepAttribute.ConstructorArguments[1].Value!),
                        Scope = (MigrationScope)migrationStepAttribute.ConstructorArguments[2].Value!,
                        Mode = (MigrationStepMode)migrationStepAttribute.ConstructorArguments[3].Value!,
                        Warning = (string?)migrationStepAttribute.ConstructorArguments[4].Value,
                        MethodName = methodSymbol.Name,
                        IsTask = methodSymbol.ReturnType.ToDisplayString() == "System.Threading.Tasks.Task"
                    };
                }
            }
        }
    }

    private static (ClassDeclarationSyntax Declaration, bool HasAttribute) GetClassDeclaration(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class
        foreach (var attributeSyntax in classDeclarationSyntax.GetAttributes())
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
            {
                continue; // if we can't get the symbol, ignore it
            }

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check for the full name of the attribute
            if (attributeName == $"{Namespace}.{AttributeName}")
            {
                return (classDeclarationSyntax, true);
            }
        }

        return (classDeclarationSyntax, false);
    }

    private static string Service(MigrationStep step) =>
        step.Scope == MigrationScope.Application ? "_configuration" : "_profile.Current";

    private class MigrationStep
    {
        public string? Namespace { get; set; }
        public string? ClassName { get; set; }
        public int Order { get; set; }
        public string? MethodName { get; set; }
        public Guid? Guid { get; set; }
        public bool IsTask { get; set; }
        public MigrationStepMode Mode { get; set; }
        public MigrationScope Scope { get; set; }
        public string? Warning { get; set; }
    }
}