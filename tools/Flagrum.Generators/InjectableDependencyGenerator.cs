using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Flagrum.Generators.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Flagrum.Generators;

[Generator]
public class InjectableDependencyGenerator : IIncrementalGenerator
{
    private const string Namespace = "Flagrum.Generators";
    private const string AttributeName = "InjectableDependencyAttribute";
    private const string InjectAttributeName = "InjectAttribute";

    private const string AttributeSourceCode =
        $$"""
          /// <auto-generated/>

          namespace {{Namespace}};

          [System.AttributeUsage(System.AttributeTargets.Class)]
          public class {{AttributeName}} : System.Attribute
          {
              public Microsoft.Extensions.DependencyInjection.ServiceLifetime Lifetime { get; }
              
              public {{AttributeName}}(Microsoft.Extensions.DependencyInjection.ServiceLifetime lifetime)
              {
                  Lifetime = lifetime;
              }
          }
          
          [System.AttributeUsage(System.AttributeTargets.Field)]
          public class {{InjectAttributeName}} : System.Attribute;
          """;

    private const string ExtensionSourceCode =
        $$"""
          /// <auto-generated/>
          
          using Microsoft.Extensions.DependencyInjection;
          
          namespace {{Namespace}};
          
          public static class FlagrumGeneratorsServiceExtensions
          {
              public static IServiceCollection Add%%PROJECTNAME%%(this IServiceCollection services)
              {
          %%PLACEHOLDER%%
          
                  return services;
              }
          }
          """;
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the [InjectableDependency] attribute to the source
        context.RegisterPostInitializationOutput(c => c.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));
        
        // Filter down to classes with the attribute
        var filteredClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (c, _) => GetClassDeclaration(c))
            .Where(r => r.HasAttribute)
            .Select((r, _) => r.Declaration)
            .Collect();
        
        // Generate the source code
        context.RegisterSourceOutput(context.CompilationProvider.Combine(filteredClasses),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        var builder = new StringBuilder();
        
        foreach (var classDeclaration in classDeclarations)
        {
            var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

            if (model.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
            {
                continue;
            }
            
            // Generate the partial class for the auto-injection
            var nameSpace = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classDeclaration.Identifier.Text;
            var fields = GetInjectedFields(classSymbol).ToList();

            if (fields.Any())
            {
                var source = $$"""
                               /// <auto-generated />

                               namespace {{nameSpace}};

                               public partial class {{className}}
                               {
                                   public {{className}}(
                                       {{string.Join(",\r\n        ", fields.Select(f => $"{f.TypeName} {f.Name!.Substring(1)}"))}}
                                   )
                                   {
                                       {{string.Join("\r\n        ", fields.Select(f => $"{f.Name} = {f.Name!.Substring(1)};"))}}
                                   }
                               }
                               """;

                context.AddSource($"{nameSpace}.{className}.di.g.cs", SourceText.From(source, Encoding.UTF8));
            }

            // Add the service to the DI container
            var attribute = classSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == $"{Namespace}.{AttributeName}");

            if (attribute != null)
            {
                var lifetime = (int)attribute.ConstructorArguments[0].Value! switch
                {
                    0 => "Singleton",
                    2 => "Transient",
                    _ => "Scoped"
                };

                builder.AppendLine($"        services.Add{lifetime}<{nameSpace}.{className}>();");
            }
        }

        var extensions = ExtensionSourceCode
            .Replace("%%PLACEHOLDER%%", builder.ToString())
            .Replace("%%PROJECTNAME%%", compilation.AssemblyName!.Replace(".", ""));
        
        context.AddSource("FlagrumGeneratorsServiceExtensions.g.cs", SourceText.From(extensions, Encoding.UTF8));
    }
    
    private static IEnumerable<InjectedField> GetInjectedFields(ITypeSymbol typeSymbol)
    {
        return typeSymbol.GetMembers().OfType<IFieldSymbol>()
            .Where(f => f.GetAttributes()
                .Any(a => a.AttributeClass?.ToDisplayString() == $"{Namespace}.{InjectAttributeName}"))
            .Select(f =>
            {
                var typeName = $"{f.Type.ContainingNamespace}.{f.Type.Name}";
                if (f.Type is INamedTypeSymbol {IsGenericType: true} namedType)
                {
                    var typeArguments = string.Join(", ", namedType.TypeArguments
                        .Select(t => $"{t.ContainingNamespace}.{t.Name}"));
                    typeName = $"{typeName}<{typeArguments}>";
                }
                
                return new InjectedField
                {
                    Name = f.Name,
                    TypeName = typeName
                };
            });
    }
    
    private static (ClassDeclarationSyntax Declaration, bool HasAttribute) GetClassDeclaration(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class
        foreach (var attributeSyntax in classDeclarationSyntax.GetAttributes())
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
            {
                continue; // if we can't get the symbol, ignore it
            }

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check for the full name of the attribute
            if (attributeName == $"{Namespace}.{AttributeName}")
            {
                return (classDeclarationSyntax, true);
            }
        }

        return classDeclarationSyntax.ChildNodes()
            .Any(n => n is FieldDeclarationSyntax field 
                      && field.AttributeLists.Any(a => a.ChildNodes()
                        .Any(c => c is AttributeSyntax attribute 
                                  && IsInjectAttribute(attribute)))) 
            ? (classDeclarationSyntax, true) 
            : (classDeclarationSyntax, false);
    }
    
    private static bool IsInjectAttribute(AttributeSyntax attribute)
    {
        var name = attribute.Name switch
        {
            SimpleNameSyntax simpleNameSyntax => simpleNameSyntax.Identifier.Text,
            QualifiedNameSyntax qualifiedNameSyntax => qualifiedNameSyntax.Right.Identifier.Text,
            _ => null
        };

        return name is "Inject" or "InjectAttribute";
    }

    private class InjectedField
    {
        public string? Name { get; set; }
        public string? TypeName { get; set; }
    }
}