using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Flagrum.Generators;

[Generator]
public sealed class ConcurrentPropertySourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var injectedFields = context.SyntaxProvider
            .CreateSyntaxProvider(Predicate, Transform)
            .Where(type => type != null)
            .Collect();

        context.RegisterSourceOutput(injectedFields, Generate);
    }

    private static void Generate(SourceProductionContext context, ImmutableArray<ITypeSymbol?> types)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (var type in types)
        {
            var code = GenerateCode(type!);
            var typeNamespace = type!.ContainingNamespace.IsGlobalNamespace ? null : $"{type.ContainingNamespace}.";
            context.AddSource($"{typeNamespace}{type.Name}.g.cs", code);
        }
    }

    private static string GenerateCode(ITypeSymbol type)
    {
        var typeNamespace = type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToString();
        var name = type.Name;
        var fields = GetInjectedFields(type);

        return $$"""
                 /// <auto-generated />

                 using MemoryPack;
                 using Flagrum.Core.Persistence;

                 {{(typeNamespace == null ? null : $"namespace {typeNamespace};")}}

                 public partial class {{name}}
                 {
                     private readonly object _lock = new();
                     
                     {{string.Join("\r\n    ", fields.Select(kvp => $"public {kvp.Value} {CapitaliseFirst(kvp.Key.Substring(1))} {{ get {{ lock(_lock) {{ return {kvp.Key}; }} }} set {{ lock(_lock) {{ {kvp.Key} = value; Save(); }} }} }}"))}}
                 }
                 """;
    }

    private static string CapitaliseFirst(string value)
    {
        var capitalised = value[0].ToString().ToUpper()[0];
        var asArray = value.ToCharArray();
        asArray[0] = capitalised;
        return new string(asArray);
    }

    private static Dictionary<string, string> GetInjectedFields(ITypeSymbol type)
    {
        var fields = new Dictionary<string, string>();
        foreach (var field in type.GetMembers().OfType<IFieldSymbol>())
        {
            if (field.GetAttributes().Any(a => a.AttributeClass?.Name == "ConcurrentPropertyAttribute"))
            {
                fields[field.Name] = $"{field.Type.ContainingNamespace}.{field.Type.Name}";
            }
        }

        return fields;
    }

    private static bool Predicate(SyntaxNode node, CancellationToken cancellationToken)
    {
        if (node is not ClassDeclarationSyntax classDeclaration)
        {
            return false;
        }

        return classDeclaration.ChildNodes()
            .Any(n => n is FieldDeclarationSyntax field && field.AttributeLists
                .Any(a => a.ChildNodes()
                    .Any(c => c is AttributeSyntax attribute && IsInjectAttribute(attribute))));
    }

    private static bool IsInjectAttribute(AttributeSyntax attribute)
    {
        var name = attribute.Name switch
        {
            SimpleNameSyntax simpleNameSyntax => simpleNameSyntax.Identifier.Text,
            QualifiedNameSyntax qualifiedNameSyntax => qualifiedNameSyntax.Right.Identifier.Text,
            _ => null
        };

        return name is "ConcurrentProperty" or "ConcurrentPropertyAttribute";
    }

    private static ITypeSymbol? Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        return context.SemanticModel.GetDeclaredSymbol(context.Node, cancellationToken) as ITypeSymbol;
    }
}